# 開発計画

段階的に最小機能から拡張する。

## 1) 最小コア
- 構文: 関数定義/呼び出し、レコード、代数的データ型、パターンマッチ、式指向ブロック、演算子宣言（優先度/結合性）。
- 型: 静的型付け（構造的部分型なし）、単純型＋型推論（H-M基盤）、基本型クラス（Eq/Ord/Show）とインスタンス解決。
- 効果: 純粋関数のみ（エフェクト行は空）。
- トランスパイル: JS(ES2020) への単純なAST→JS変換（最適化なし）。
- ツール: CLI（compile/run/REPL）、最小LSPフック（補完/診断なしでも可）。

## 2) 効果システム導入
- アルジェブラ的エフェクト＋`handle` 構文、エフェクト行の型付け、サブエフェクト関係の基本形。
- JS出力: `async/await` とPromise合成への変換、不要エフェクトの消去。
- 簡易最適化: デッドコード除去のみ。

## 3) 型クラスとコンパイル時多態拡張
- 型クラスのコヒーレンス/オーバーラップ/孤児規則の実装。
- 多相リテラルの解決（数値/文字列）、型推論との統合。
- エフェクト多相を型推論に追加。

## 4) 所有権/線形型とリソース解放
- 線形型・所有権/借用の静的検証を導入し、`using`/`Disposable` による決定的解放を自動生成。
- エフェクト行と統合し、リソース操作を型で制約。
- JS出力: try/finally 展開で cleanup 保証。

## 5) 並行・並列モデル確立
- 選定した並行モデル（例: タスクスコープ＋チャネル）を第一級化し、構造化並行とキャンセル安全を型で保証。
- エフェクト行との合成規則とキャンセル時の `handle` 挙動を仕様通りに実装。

## 6) 最適化とIR強化
- SSA/ANF など段階的IRを導入し、インライン/CSE/融合/部分評価を実装。
- 最適化ヒント（@inline/@noinline/@pure）を反映。

## 7) JSX風HTML構文とテンプレート安全
- JSX風構文のパーサと型チェック（属性型クラス、イベントのエフェクト制約）。
- VDOM/DOM/SSR バックエンド出力、コンテキスト感知エスケープをデフォルト化。
- `unsafe` 挿入は警告またはエラーに。

## 8) ツールチェーンとCI強化
- `fmt + lint + typecheck + test + bench` 統合コマンド、ビルドキャッシュとインクリメンタルチェック。
- プロパティテスト/スナップショット/`doc-test`/`perf-test` の実装。
- ドキュメント生成（型/エフェクト/能力シグネチャ表）。

## 9) クロスコンパイルとターゲットプリセット
- ブラウザ/Node/Workers/WASM（WASI/ブラウザ）への出力プリセット、polyfill戦略とGC配慮。
- コード署名/ロックファイル検証、サプライチェーン安全。

## 10) 拡張とハードウェア利用
- WebGPU/WebGL/Simd/Atomics の安全バインディング、TypedArray/SharedArrayBuffer による並列計算。
- ロケール安全、テレメトリ統合、決定性/再現性フラグを仕上げる。

## 各ステージの進め方
- ステージごとに: (a) 仕様最小スコープ確定 → (b) 実装 → (c) 単体/プロパティテスト → (d) サンプルコードとドキュメント更新 → (e) 次ステージ着手。
- 常に型安全を前提とし、安全を弱めるフラグは提供しない。

---
source: tests/snapshots/hm_inference.rs
assertion_line: 78
expression: out
---
polymorphic_fn
fn id(a) = a; id(1); id(true)
---
function id(a) { return a; }
id(1);
id(true)
===
higher_order_apply
fn apply(f, x) = f(x); fn inc(n) = n + 1; apply(inc, 41)
---
function apply(f, x) { return f(x); }
function inc(n) { return n + 1; }
apply(inc, 41)
===
polymorphic_predicate
fn eq(x, y) = x == y; eq(1, 1); eq("a", "b")
---
function eq(x, y) { return x == y; }
eq(1, 1);
eq("a", "b")
===
recursive_fact
fn fact(n) = match(n){case 0 => 1; case _ => n * fact(n - 1)}; fact(5)
---
function fact(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * fact(n - 1); } return undefined; })(); }
fact(5)
===
mutual_even_odd
fn is_even(n) = match(n){case 0 => true; case _ => is_odd(n - 1)};
fn is_odd(n) = match(n){case 0 => false; case _ => is_even(n - 1)};
is_even(4); is_odd(5)
---
function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); }
function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); }
is_even(4);
is_odd(5)
===
lambda_let
let id = \x -> x; id(3)
---
let id = (function(x) { return x; });
id(3)
===
lambda_closure
fn wrap(x) = { let add = \y -> x + y; add }; wrap(1)
---
function wrap(x) { return (() => { let add = (function(y) { return x + y; }); return add; })(); }
wrap(1)
===
mutual_in_block
{ fn is_even(n) = match(n){case 0 => true; case _ => is_odd(n - 1)}; fn is_odd(n) = match(n){case 0 => false; case _ => is_even(n - 1)}; is_even(6) }
---
(() => { function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); } function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); } return is_even(6); })()
===
forward_call_to_mutual
start(); fn start() = is_even(3); fn is_even(n) = match(n){case 0 => true; case _ => is_odd(n - 1)}; fn is_odd(n) = match(n){case 0 => false; case _ => is_even(n - 1)}
---
start();
function start() { return is_even(3); }
function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); }
function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); }
===
let_rec_factorial
let rec fact = \n -> match(n){case 0 => 1; case _ => n * fact(n - 1)}; fact(5)
---
let fact = (function(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * fact(n - 1); } return undefined; })(); });
fact(5)
===
let_rec_in_block
{ let rec sum = \n -> match(n){case 0 => 0; case _ => n + sum(n - 1)}; sum(3) }
---
(() => { let sum = (function(n) { return (() => { const __match = n; if (__match === 0) { return 0; } else if (true) { return n + sum(n - 1); } return undefined; })(); }); return sum(3); })()
===
tuple_literal
(1, true, "s")
---
[1, true, "s"]
===
tuple_pattern_match
match((1, true)){case (1, true) => 0; case _ => 1}
---
(() => { const __match = [1, true]; if (Array.isArray(__match) && __match.length === 2 && __match[0] === 1 && __match[1] === true) { return 0; } else if (true) { return 1; } return undefined; })()
===
list_literal
[1, 2, 3]
---
[1, 2, 3]
===
list_cons_match
match([1, 2]){case [h, ...t] => h; case _ => 0}
---
(() => { const __match = [1, 2]; if (Array.isArray(__match) && __match.length >= 1 && true) { const h = __match[0]; const t = __match.slice(1); return h; } else if (true) { return 0; } return undefined; })()
===
list_rest_ignored
match([1, 2]){case [h, ...] => h; case _ => 0}
---
(() => { const __match = [1, 2]; if (Array.isArray(__match) && __match.length >= 1 && true) { const h = __match[0]; return h; } else if (true) { return 0; } return undefined; })()
===
fix_factorial
let fact = fix(\rec -> \n -> match(n){case 0 => 1; case _ => n * rec(n - 1)}); fact(4)
---
function fix(f) { return (function(x) { return f(function(v) { return x(x)(v); }); })(function(x) { return f(function(v) { return x(x)(v); }); }); }
let fact = fix((function(rec) { return (function(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * rec(n - 1); } return undefined; })(); }); }));
fact(4)

---
source: tests/snapshots/hm_inference.rs
expression: out
---
polymorphic_fn
(defn id [a] a) (id 1) (id true)
---
function id(a) { return a; }
id(1);
id(true)
===
higher_order_apply
(defn apply [f x] (f x)) (defn inc [n] (+ n 1)) (apply inc 41)
---
function apply(f, x) { return f(x); }
function inc(n) { return n + 1; }
apply(inc, 41)
===
polymorphic_predicate
(defn eq [x y] (== x y)) (eq 1 1) (eq "a" "b")
---
function eq(x, y) { return x == y; }
eq(1, 1);
eq("a", "b")
===
recursive_fact
(defn fact [n] (match n [0 1] [_ (* n (fact (- n 1)))])) (fact 5)
---
function fact(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * fact(n - 1); } return undefined; })(); }
fact(5)
===
mutual_even_odd
(defn is_even [n] (match n [0 true] [_ (is_odd (- n 1))])) (defn is_odd [n] (match n [0 false] [_ (is_even (- n 1))])) (is_even 4) (is_odd 5)
---
function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); }
function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); }
is_even(4);
is_odd(5)
===
lambda_let
(let [id (fn [x] x)] (id 3))
---
(() => { let id = (function(x) { return x; }); return id(3); })()
===
lambda_closure
(defn wrap [x] (do (let [add (fn [y] (+ x y))] add))) (wrap 1)
---
function wrap(x) { return (() => { return (() => { let add = (function(y) { return x + y; }); return add; })(); })(); }
wrap(1)
===
mutual_in_block
(do (defn is_even [n] (match n [0 true] [_ (is_odd (- n 1))])) (defn is_odd [n] (match n [0 false] [_ (is_even (- n 1))])) (is_even 6))
---
(() => { function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); } function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); } return is_even(6); })()
===
forward_call_to_mutual
(start) (defn start [] (is_even 3)) (defn is_even [n] (match n [0 true] [_ (is_odd (- n 1))])) (defn is_odd [n] (match n [0 false] [_ (is_even (- n 1))]))
---
start();
function start() { return is_even(3); }
function is_even(n) { return (() => { const __match = n; if (__match === 0) { return true; } else if (true) { return is_odd(n - 1); } return undefined; })(); }
function is_odd(n) { return (() => { const __match = n; if (__match === 0) { return false; } else if (true) { return is_even(n - 1); } return undefined; })(); }
===
let_rec_factorial
(let-rec [fact (fn [n] (match n [0 1] [_ (* n (fact (- n 1)))]))] (fact 5))
---
(() => { let fact = (function(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * fact(n - 1); } return undefined; })(); }); return fact(5); })()
===
let_rec_in_block
(do (let-rec [sum (fn [n] (match n [0 0] [_ (+ n (sum (- n 1)))]))] (sum 3)))
---
(() => { return (() => { let sum = (function(n) { return (() => { const __match = n; if (__match === 0) { return 0; } else if (true) { return n + sum(n - 1); } return undefined; })(); }); return sum(3); })(); })()
===
tuple_literal
[1, true, "s"]
---
[1, true, "s"]
===
tuple_pattern_match
(match [1, true] [[1, true] 0] [_ 1])
---
(() => { const __match = [1, true]; if (Array.isArray(__match) && __match.length === 2 && __match[0] === 1 && __match[1] === true) { return 0; } else if (true) { return 1; } return undefined; })()
===
list_literal
[1 2 3]
---
[1, 2, 3]
===
list_cons_match
(match [1 2] [[h ...t] h] [_ 0])
---
(() => { const __match = [1, 2]; if (Array.isArray(__match) && __match.length >= 1 && true) { const h = __match[0]; const t = __match.slice(1); return h; } else if (true) { return 0; } return undefined; })()
===
list_rest_ignored
(match [1 2] [[h ...] h] [_ 0])
---
(() => { const __match = [1, 2]; if (Array.isArray(__match) && __match.length >= 1 && true) { const h = __match[0]; return h; } else if (true) { return 0; } return undefined; })()
===
fix_factorial
(let [fact (fix (fn [rec] (fn [n] (match n [0 1] [_ (* n (rec (- n 1)))]))))] (fact 4))
---
function fix(f) { return (function(x) { return f(function(v) { return x(x)(v); }); })(function(x) { return f(function(v) { return x(x)(v); }); }); }
(() => { let fact = fix((function(rec) { return (function(n) { return (() => { const __match = n; if (__match === 0) { return 1; } else if (true) { return n * rec(n - 1); } return undefined; })(); }); })); return fact(4); })()
===
external_simple
(external log (-> String Unit) "console.log") (log "hello")
---
const log = console.log;
log("hello")
===
external_with_return
(external parse_int (-> String Number) "parseInt") (+ (parse_int "42") 1)
---
const parse_int = parseInt;
parse_int("42") + 1
===
external_multi_arg
(external pow (-> Number Number Number) "Math.pow") (pow 2 10)
---
const pow = Math.pow;
pow(2, 10)
===
curried_function
(let [add (fn [x] (fn [y] (+ x y)))] ((add 1) 2))
---
(() => { let add = (function(x) { return (function(y) { return x + y; }); }); return add(1)(2); })()
===
chained_call_make_adder
(defn make_adder [x: Number] (fn [y] (+ x y))) ((make_adder 5) 10)
---
function make_adder(x) { return (function(y) { return x + y; }); }
make_adder(5)(10)
===
nested_closure_capture
(defn outer [x: Number] (do (defn inner [y: Number] (fn [z] (+ (+ x y) z))) inner)) (((outer 1) 2) 3)
---
function outer(x) { return (() => { function inner(y) { return (function(z) { return x + y + z; }); } return inner; })(); }
outer(1)(2)(3)
